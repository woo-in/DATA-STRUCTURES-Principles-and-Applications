상품 z1 의 제조원 업체는 유일하지만 상품 z1 의 구매자는 유일하지 않기 때문에 
그룹과 공유는 나누어 봐야 한다. 

이미 그룹화된 데이터 원소들이 또 다른 그룹에 의해 공유되는 새로운 개념이 된다. 
그룹과 공유의 차이점은 ? 

그룹 -------- 
A : a , b , c
B : e , g , l 
... 
------------

그룹 --------
A : b , c , d 
B : b , c , e 
-------------
이런식으로 그룹마다 같은 원소를 둬 공유를 모델링 하는 것은 허용되지 않는다. 
( 기억장소 낭비 ) 

공유 시 공유되는 데이터 원소를 공유하는 그룹마다 복사하여 제공하는 것은 기억장소의 낭비를 초래하므로
허용하지 않는다. 

쇼핑몰의 상품들 

구매자 A : x1 , y1 
구매자 B : z1 
구매자 C : y1 , z1 , z2 

그룹을 쓰지 않고 어떻게 모델링할까 ? ( 그룹쓰면 기억장소의 낭비 ) 

레코드의 리스트를 활용 - 걍 그룹으로 모델링 한 거 잖아

포인터의 리스트 사용 

1. 배열 또는 연결리스트 기반의 리스트를 사용하여 이때 type 은 pointer to element 

2. element 를 그룹의 주소가 되게 한다. ( 참조할 수 있는 ) 

장 : 단순하다 / 기억장소의 사용을 최소화 한다. ( element 가 복잡하면 ) 
단 특정 원소의 관점에서 처리가 곤란해진다. 
공유되는 요소 A 를 포함하는 모든 것들 

설계 : 리스트 2개 
한개는 type : 포인터 to element 
한개는 type : struct ( 문자열 / 일련 번호 ) 


배열 / 연결리스트 



가정 : 상품을 산 구매자들... 


공유 --------------  

1. 그룹 / element 리스트 
2. 직접 구현 ( 최적화 ) 

------------------ 

 
전제 : 
상품을 산 구매자들...  
- A ~ Z 그룹까지 존재 
- 최적화 버전 

메서드 
- 초기화 
-공유자원 추가 ( 물건 입고 ) 
-해당 그룹에 공유자원 연결 ( 상품 구매 ) 
-해당 그룹에 공유자원 연결해제 ( 상품 환불 ) 
-해당 고객의 상품 구매 내역 보기 
- 해제

배열 or 연결리스트 고민거리 3가지 


          

1. 상품들 
2. 고객이 산 상품들 
3. 고객들 


<배열,연결리스트>                1   /   2   /   3 

물건입고

단순히 상품들에 추가하면된다.
배열 , 연결리스트 둘다 O(1) 에할 수는 있다.
배열은 끝에 추가해서 옮기는거 방지하고 연결리스트는 처음에 추가해서 순회안하게 하고  
1 

고객추가

마찬가지로 단순히 고객의 추가다.
배열 연결리스트 둘다 O(1)에 할 수 있다.                                       
3 


상품구매         

상품환불 

구매내역보기 

해제 




결론 : 모두 연결리스트 기반으로 한다. 
배열이 우열한 점이 인덱스로 바로 접근할 수 있다 인데 메쏘드들이 전부 인덱스로 접근하는 관점을 가지기에는
딱히 말이안됌. 
 





InitHandler() 

ApplyNewCustomer() 
히스토리 , 고객이름 , 고객 숫자 받고 연결 처음에 연결할 것. 

ApplyNewProduct() 


void PurchaseNewProduct(cph, customer_name , product_name)
{
	확인된 product 를 확인된 customer 의 purchase 에 넣는다. 

1. product 순회하면서 일치하는거 찾고 변수에 저장
2. customer 순회하면서 일치하는 거 찾고 변수에 저장 
3. customer 에 purchase 에 삽입 


} 


RefundNewProduct( cph , customer_name , product_name ) 
1. product 순회하면서 일치하는거 찾고 변수에 저장
2. customer 순회하면서 일치하는 거 찾고 변수에 저장 
3. 고객이 산 물품 product 순회하면서 찾기 
찾으면 환불 / 못찾으면 환불 X 


PrintPurchaseHistory() 



dealloc  ** 























